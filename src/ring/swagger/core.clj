(ns ring.swagger.core
  (:require [clojure.string :as str]
            [clojure.walk :as walk]
            [ring.util.http-response :as r]
            [schema.core :as s]
            [plumbing.core :refer :all]
            ;; needed for the json-encoders
            ring.swagger.json
            [ring.swagger.schema :as schema]
            [ring.swagger.common :refer :all]
            [ring.swagger.json-schema :as jsons]
            [schema-tools.walk :as stw]
            [flatland.ordered.set :as os]
            [clojure.string :as string]
            [org.tobereplaced.lettercase :as lc])
  (:import (clojure.lang IMapEntry)
           (javax.servlet ServletContext)))

;;
;; Helpers
;;

(defn required-keys [schema]
  (filterv s/required-key? (keys schema)))

(defn strict-schema
  "removes open keys from schema"
  [schema]
  {:pre [(map? schema)]}
  (dissoc schema s/Keyword))

;;
;; Models
;;

(s/defschema ResponseMessage {:code Long
                              (s/optional-key :message) String
                              (s/optional-key :responseModel) s/Any})

;;
;; Schema transformations
;;

(defn- full-name [path] (->> path (map name) (map lc/capitalized) (apply str) symbol))

(defn map-entry? [x]
  (instance? IMapEntry x))

(defn peek-schema
  "Recurisively seeks the form with schema-name.
   Walks over sets, vectors and Schema predicates."
  [schema]
  (let [it (atom nil)]
    ((fn walk [x]
       (stw/walk
         x
         (fn [x]
           (if (and (plain-map? x) (s/schema-name x))
             (do (reset! it x) x)
             (walk x)))
         identity)) [schema])
    @it))

(defn peek-schema-name
  "Recurisively seeks the schema-name withing a schema.
   Walks over sets, vectors and Schema predicates."
  [schema]
  (s/schema-name (peek-schema schema)))

(defn name-schemas [names schema]
  (stw/walk
    schema
    (fn [x]
      (if (map-entry? x)
        [(key x)
         (name-schemas
           (conj names
                 (if (s/specific-key? (key x))
                   (s/explicit-schema-key (key x))
                   (gensym (pr-str (key x))))) (val x))]
        (name-schemas names x)))
    (fn [x]
      (if (plain-map? x)
        (if-not (s/schema-name x)
          (with-meta x {:name (full-name names)})
          x)
        x))))

(defn with-named-sub-schemas
  "Traverses a schema tree of Maps, Sets and Sequences and add Schema-name to all
   anonymous maps between the root and any named schemas in thre tree. Names of the
   schemas are generated by the following: Root schema name (or a generated name) +
   all keys in the path CamelCased"
  ([schema] (with-named-sub-schemas schema "schema"))
  ([schema prefix]
   (name-schemas [(or (s/schema-name schema) (gensym prefix))] schema)))

(defn transform [schema]
  (let [required (required-keys schema)
        required (if-not (empty? required) required)]
    (remove-empty-keys
      {:id (s/schema-name schema)
       :properties (jsons/properties schema)
       :required required})))

;; NOTE: silently ignores non-map schemas
(defn collect-models
  "Walks through the data structure and collects all Schemas
  into a map schema-name->#{values}. Note: schame-name can link
  to sevetal implementations."
  [x]
  (let [schemas (atom {})]
    (walk/prewalk
      (fn [x]
        (when-let [schema-name (and (plain-map? x) (s/schema-name x))]
          (let [schema (if (var? x) @x x)]
            (swap!
              schemas update-in [schema-name]
              (fn [x] (conj (or x (os/ordered-set)) schema)))))
        x)
      x)
    @schemas))

;;
;; duplicates
;;

(defn ignore-duplicate-schemas [schema-name values]
  [schema-name (first values)])

; FIXME: custom predicates & regexps don't work
(defn fail-on-duplicate-schema! [schema-name values]
  (if-not (seq (rest values))
    [schema-name (first values)]
    (throw
      (IllegalArgumentException.
        (str
          "Looks like you're trying to define two models with the same name ("
          schema-name "), but different values:\n\n" (string/join "\n\n" values) "\n\n"
          "There is no way to create valid api docs with this setup. You may have
          multiple namespaces defining same Schema names or you have created copies"
          "of the scehmas with clojure.core fn's like \"select-keys\". Please check"
          "out schema-tools.core -transformers.")))))

(defn handle-duplicate-schemas [f schemas]
  (into
    (empty schemas)
    (for [[k v] schemas]
      (f k v))))

;;
;; transformers
;;

(defn transform-models [schemas]
  (->> schemas
       collect-models
       (handle-duplicate-schemas ignore-duplicate-schemas)
       (map (juxt key (comp transform val)))
       (into {})))

(defn extract-models [details]
  (let [route-meta (->> details
                        :routes
                        (map :metadata))
        return-models (->> route-meta
                           (keep :return)
                           flatten)
        body-models (->> route-meta
                         (mapcat :parameters)
                         (filter (fn-> :type (= :body)))
                         (keep :model)
                         flatten)
        response-models (->> route-meta
                             (mapcat :responseMessages)
                             (keep :responseModel)
                             flatten)
        all-models (->> (concat body-models return-models response-models)
                        flatten
                        (map with-named-sub-schemas))]
    (->> all-models
         (map (juxt peek-schema-name identity))
         (filter (fn-> first))
         (into {}))))

;;
;; Route generation
;;

(defn path-params [s]
  (map (comp keyword second) (re-seq #":(.[^:|(/]*)[/]?" s)))

(defn string-path-parameters [uri]
  (let [params (path-params uri)]
    (if (seq params)
      {:type :path
       :model (zipmap params (repeat String))})))

(defn swagger-path [uri]
  (str/replace uri #":([^/]+)" "{$1}"))

(defn generate-nick [{:keys [method uri]}]
  (-> (str (name method) " " uri)
    (str/replace #"/" " ")
    (str/replace #"-" "_")
    (str/replace #":" " by ")
    lc/mixed))

(def swagger-defaults      {:swaggerVersion "1.2" :apiVersion "0.0.1"})
(def resource-defaults     {:produces ["application/json"]
                            :consumes ["application/json"]})
(def api-declaration-keys  [:title :description :termsOfServiceUrl :contact :license :licenseUrl])

(defn join-paths
  "Join several paths together with \"/\". If path ends with a slash,
   another slash is not added."
  [& paths]
  (str/replace (str/replace (str/join "/" (remove nil? paths)) #"([/]+)" "/") #"/$" ""))

(defn context
  "Context of a request. Defaults to \"\", but has the
   servlet-context in the legacy app-server environments."
  [{:keys [^ServletContext servlet-context]}]
  (if servlet-context (.getContextPath servlet-context) ""))

(defn basepath
  "extract a base-path from ring request. Doesn't return default ports
   and reads the header \"x-forwarded-proto\" only if it's set to value
   \"https\". (e.g. your ring-app is behind a nginx reverse https-proxy).
   Adds possible servlet-context when running in legacy app-server."
  [{:keys [scheme server-name server-port headers] :as request}]
  (let [x-forwarded-proto (headers "x-forwarded-proto")
        context (context request)
        scheme (if (= x-forwarded-proto "https") "https" (name scheme))
        port (if (#{80 443} server-port) "" (str ":" server-port))]
    (str scheme "://" server-name port context)))

;;
;; Convert parameters
;;

(defmulti ^:private extract-parameter
  (fn [{:keys [type]}] type))

(defmethod extract-parameter :body [{:keys [model type]}]
  (if model
    (vector
      (merge {:paramType type
              :name (some-> model schema/extract-schema-name str/lower-case)
              :description ""
              :required true}
             (jsons/->json model {:parameter? true})))))

(defmethod extract-parameter :default [{:keys [model type] :as it}]
  (if model
    (for [[k v] (-> model value-of strict-schema)
          :when (s/specific-key? k)
          :let [rk (s/explicit-schema-key (eval k))]]
      (merge {:paramType type
              :name (name rk)
              :description ""
              :required (s/required-key? k)}
             (jsons/->json v)))))

(defn convert-parameters [parameters]
  (mapcat extract-parameter parameters))

(s/defn ^:always-validate convert-response-messages [messages :- [ResponseMessage]]
  (for [{:keys [responseModel] :as message} messages]
    (if (and responseModel (schema/named-schema? responseModel))
      (update-in message [:responseModel] (fn [x] (:type (jsons/->json x {:parameter? true}))))
      (dissoc message :responseModel))))

;;
;; Routing
;;

(defn api-listing [parameters swagger]
  (r/ok
    (merge
      swagger-defaults
      (select-keys parameters [:apiVersion])
      {:info (select-keys parameters api-declaration-keys)
       :authorizations (:authorizations parameters {})
       :apis (for [[api details] swagger]
               {:path (str "/" (name api))
                :description (or (:description details) "")})})))

(defn api-declaration [parameters swagger api basepath]
  (if-let [details (and swagger (swagger api))]
    (r/ok
      (merge
        swagger-defaults
        resource-defaults
        (select-keys parameters [:apiVersion :produces :consumes])
        {:basePath basepath
         :resourcePath (str "/" api)
         :models (transform-models (extract-models details))
         :apis (for [{:keys [method uri metadata] :as route} (:routes details)
                     :let [{:keys [return summary notes nickname parameters
                                   responseMessages authorizations]} metadata]]
                 {:path (swagger-path uri)
                  :operations [(merge
                                 (jsons/->json return {:parameter? true})
                                 {:method (-> method name .toUpperCase)
                                  :authorizations (or authorizations {})
                                  :summary (or summary "")
                                  :notes (or notes "")
                                  :nickname (or nickname (generate-nick route))
                                  :responseMessages (convert-response-messages responseMessages)
                                  :parameters (convert-parameters parameters)})]})}))))
